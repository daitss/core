#!/usr/bin/env ruby

require 'optparse'
require 'uri'
require 'ostruct'
require 'digest/md5'
require 'fileutils'
require 'curb'

# a commandline DAITSS 2 submission client
# takes a specified package on a filesystem, zips it up, and POSTs it to the submission at the specified url as the specified
# operations agent.

# dependencies:
# zip

def get_options(args)
  config = OpenStruct.new("url" => nil, "package" => nil, "package_name" => nil)

  begin
    opts = OptionParser.new do |opt|

      opt.banner << "\nSubmits a SIP DAITSS 2"
      opt.on_tail("--help", "Show this message") { puts opts; exit }

      opt.on("--url URL", String, "URL of service to submit package to, required") { |key| config.url = key }
      opt.on("--path PATH", String, "Path on filesystem containing SIPs to submit, either --path or --package required") { |path| config.path = path }
      opt.on("--package PATH", String, "Path on filesystem to a single sip, either --path or --package required") { |path| config.package = path }
      opt.on("--username USERNAME", String, "Operations agent username, required") { |username| config.username = username }
      opt.on("--password PASSWORD", String, "Operations agent password, required") { |password| config.password = password }
      opt.on("--note NOTE", String, "Submission event note (should be in quotes)") { |note| config.note = note }
      opt.on("--batch BATCH", String, "Batch to submit package under") { |batch| config.batch = batch }
      opt.on("--delete-orig", "-d") { |delete| config.delete = delete }
    end

    opts.parse!(args)

    raise StandardError, "URL not specified" unless config.url
    raise StandardError, "Path not specified" unless config.path or config.package
    raise StandardError, "Only --path or --package can be specified, but not both" if config.path and config.package
    raise StandardError, "Username not specified" unless config.username
    raise StandardError, "Password not specified" unless config.password

    url_obj = URI.parse(config.url)

    raise StandardError, "Specified URL #{config.url} does not look like an HTTP URL" unless url_obj.scheme == "http"

    if config.path
      raise StandardError, "Specified path is not a directory" unless File.directory? config.path
    else
      raise StandardError, "Specified path is not a directory" unless File.directory? config.package
    end

  rescue => e # catch the error from opts.parse! and display
    STDERR.puts "Error parsing command line options:\n#{e.message}\n#{opts}"
    exit 1
  end

  return config
end

# zips directory to /tmp/DIRNAME.zip. Returns string with path to zip file

def zip_package path_to_package
  zip_path = File.join("/tmp", File.basename(path_to_package) + ".zip")
  FileUtils.rm_rf zip_path if File.exists? zip_path
  
  exec("cd #{File.dirname(path_to_package)}; zip -r #{zip_path} #{File.basename(path_to_package)} 2>&1; cd $PWD") if fork.nil?
  Process.wait

  raise "zip returned non-zero exit status" if $?.exitstatus != 0
  raise "zip file not found where expected" unless File.exists? zip_path

  return zip_path
end

# POSTs authentication credentials, gets cookie
def authenticate
  url = URI.parse(@config.url + "/login")

  c = Curl::Easy.new(url.to_s) 

  c.http_post(Curl::PostField.content('name', @config.username), Curl::PostField.content('password', @config.password))
  cookie_headers = c.header_str.split("\r\n").select{|n| n=~ /^Set-Cookie:/}

  if cookie_headers.length > 0 
    @cookie = cookie_headers.pop.gsub("Set-Cookie: ", "")
  else
    raise "Authentication failure"
  end
end

def submit_to_svc path_to_zip, path
  url = URI.parse(@config.url + "/packages")

  n = "sip path: #{path}"
  n += ", submission note: #{@config.note}" if @config.note
  b = @config.batch ? @config.batch : "batch name"

  c = Curl::Easy.new(url.to_s) do |curb| 
    curb.headers["Cookie"] = @cookie 
    curb.multipart_form_post = true
    curb.follow_location = true
  end

  note = Curl::PostField.content('note', n)
  batch_id = Curl::PostField.content('batch_id', b)
  sip = Curl::PostField.file('sip', path_to_zip)

  c.http_post(note, batch_id, sip)
  c.body_str
end

# returns an array of filesystem paths containing packages to submit
def find_packages
  list = Dir.glob(@config.path + "/**/*")
  list = list.select { |p| File.directory? p}
  list_u = list.select { |p| File.exists? File.join(p, File.basename(p) + ".xml") }
  list_l = list.select { |p| File.exists? File.join(p, File.basename(p) + ".XML") }

  list_l | list_u
end

# submits package at path
def submit_package path
  zipfile = zip_package path
  authenticate unless @cookie
  response = submit_to_svc zipfile, path
  FileUtils.rm_rf zipfile

  ieid = response[/E[A-Z0-9]{8}_[A-Z0-9]{6}/]

  if ieid
    if response =~ /submit/
      puts Time.now.to_s + " -- " + File.basename(path) + " -- submitted successfully: " + ieid
      FileUtils.rm_rf path if @config.delete
    elsif response =~ /reject/
      puts Time.now.to_s + " -- " + File.basename(path) + " -- rejected: " + ieid
    else
      puts Time.now.to_s + " -- " + File.basename(path) + " -- couldn't determine submission outcome: " + ieid
      puts response
      puts "==============================================="
    end
  else
    puts Time.now.to_s + " -- " + File.basename(path) + " -- submission error"
    puts response
    puts "==============================================="
  end
end

@config = get_options(ARGV) or exit

if @config.path
  list = find_packages

  STDERR.puts "No packages found in #{@config.path}" unless list.length > 0

  list.each do |pkg_path|
    begin 
      submit_package pkg_path
    rescue => e
      STDERR.puts "Error submitting #{pkg_path}: #{e.message}"
    end
  end
elsif @config.package
  submit_package @config.package
else
  exit 1
end

